\subsubsection{iterative method}
\begin{lstlisting}
<inplace splitting> - O(n)
for(int i = 2; i <= len; i *= 2) - O(log(n))
	for(int k = 0; k < i/2; k++) - O(i/2)
		for(int j = 0; j < len/i; j++) - O(n/i)

\end{lstlisting}
Simple to analyse:
\begin{math}
O(n + log(n) * i/2 * n/i) = O(log(n)*n)
\end{math}
\subsubsection{recursive method}
\begin{lstlisting}
   if(step >= len)
      return;
    fft_help(dc2, dc1, len, step*2); - O(log(n-1))
    fft_help(dc2+step, dc1+step, len, step*2); - O(log(n-1))
    for(int k=0; k<len/2; k+=step) -- O(c)
\end{lstlisting}
\begin{math}
O(2*log(n-1) * n) = O(log(n)*n)
\end{math}\newline
This is visualized with memory pattern in 1.2